        -:    0:Source:conta_palavras.cpp
        -:    1:#include <iostream>
        -:    2:
        -:    3:#include <string>
        -:    4:
        -:    5:#include <sstream>
        -:    6:
        -:    7:#include <vector>
        -:    8:
        -:    9:#include <cstdlib>
        -:   10:
        -:   11:#include <cstring>
        -:   12:
        -:   13:#include <cctype>
        -:   14:
        -:   15:#include <utility>
        -:   16:
        -:   17:/**
        -:   18: * @file conta_palavras.cpp
        -:   19: * @brief Implementação de uma função para contar palavras em um texto.
        -:   20: */
        -:   21:#include "conta_palavras.hpp"
        -:   22:
        -:   23:/** 
        -:   24: * @brief Contador de palavras
        -:   25: * @author João Carlos 
        -:   26: * @param  texto string do texto de entrada
        -:   27: * 
        -:   28: */
        -:   29:
        -:   30:
        2:   31:HashMap* build() {
        2:   32:  HashMap* hashMap = (HashMap*) malloc(sizeof(HashMap));
        2:   33:  hashMap->capacidade = 1009;  // máximo de palavras
        2:   34:  hashMap->tamanho = 0;   // quantas palavras diferentes até agora
        2:   35:  hashMap->lista = (Par**) calloc(hashMap->capacidade, sizeof(Par*));
        2:   36:  return hashMap;
        -:   37:}
        -:   38:
        4:   39:unsigned encode(HashMap* hashMap, const char* chave) {
        4:   40:  unsigned code = 0;
       24:   41:  while (*chave != '\0') {
       20:   42:    code = *chave + 31 * code;
       20:   43:    chave++;
        -:   44:  }
        4:   45:  return code % hashMap->capacidade;
        -:   46:}
        -:   47:
        2:   48:int get(HashMap* hashMap, const char* chave) {
        -:   49:  // dado determinado índice, calculado na função hash,
        -:   50:  // encontra nó(Par) inicial referente aquele índice, e faz a busca pela chave.
        2:   51:  unsigned index = encode(hashMap, chave);
        2:   52:  Par* atual = hashMap->lista[index];
        2:   53:  while (atual) {
        1:   54:    if (strcmp(atual->chave, chave) == 0) {
        1:   55:      return atual->valor;
        -:   56:    }
    #####:   57:    atual = atual->prox;
        -:   58:  }
        1:   59:  return -1;
        -:   60:}
        -:   61:
        2:   62:void add(HashMap* hashMap, const char* chave, int num) {
        2:   63:  unsigned index = encode(hashMap, chave);
        2:   64:  Par* atual = hashMap->lista[index];
        2:   65:  while (atual) {
    #####:   66:    if (strcmp(atual->chave, chave) == 0) {
    #####:   67:      atual->valor = num;
    #####:   68:      return;
        -:   69:    }
    #####:   70:    atual = atual->prox;
        -:   71:  }
        2:   72:  Par* novaChaveAuxiliar = (Par*)malloc(sizeof(Par));
        2:   73:  novaChaveAuxiliar->chave = strdup(chave);
        2:   74:  novaChaveAuxiliar->valor = num;
        2:   75:  novaChaveAuxiliar->prox = hashMap->lista[index];
        2:   76:  hashMap->lista[index] = novaChaveAuxiliar;
        2:   77:  hashMap->tamanho++;
        -:   78:}
        -:   79:
        1:   80:std::vector<std::pair<std::string, int>> processaContagem(HashMap* contador, std::vector<std::string> lista_de_palavras) {
        1:   81:  std::vector<std::pair<std::string, int>> palavrasContadas;
     1010:   82:  for (int i = 0; i < (int)contador->capacidade; i++) {
     1009:   83:    Par* atual = contador->lista[i];
     1010:   84:    while (atual) {
        1:   85:      int contagem = atual->valor;
        1:   86:      char* chave = atual->chave;
       1*:   87:      for (auto &palavra : lista_de_palavras) {
        1:   88:        if (palavra == chave) {
        1:   89:          palavrasContadas.push_back({palavra, contagem});    
        1:   90:          break;
        -:   91:        }
        -:   92:      }
        1:   93:      atual = atual->prox;
        -:   94:    }
        -:   95:  }
        1:   96:  return palavrasContadas;
    =====:   97:}
        -:   98:
        2:   99:std::vector<std::string> separaPalavras(std::string texto) {
        2:  100:  std::istringstream iss(texto);
        2:  101:  std::string palavra;
        2:  102:  std::vector <std::string> lista_de_palavras;
        6:  103:  while (iss >> palavra) {
        4:  104:    lista_de_palavras.push_back(palavra);
        -:  105:  }
        4:  106:  return lista_de_palavras;
        2:  107:}
        -:  108:
        1:  109:std::string removePontuacao(std::string palavra) {
        1:  110:  std::string resultado;
       21:  111:  for (char& letra : palavra) {
       20:  112:    if (!std::ispunct(letra)) {
       18:  113:      resultado.push_back(letra);
        -:  114:    }
        -:  115:  }
        1:  116:  return resultado;
    =====:  117:}
        -:  118:
        2:  119:bool checaTextoVazio(std::string texto) {
        2:  120:  if (texto == "") return true;
        1:  121:  return false;
        -:  122:}
        -:  123:
        2:  124:std::vector<std::pair<std::string, int>> ContaPalavras(std::string texto) {
        2:  125:  if (checaTextoVazio(texto)) {
        1:  126:    return std::vector<std::pair<std::string, int>> ();
        -:  127:  }
        1:  128:  HashMap* Contador = build();
        1:  129:  std::vector<std::string> lista_de_palavras = separaPalavras(texto);
        2:  130:  for (auto palavra_atual : lista_de_palavras) {
        1:  131:    int contagem = get(Contador, palavra_atual.c_str());
        1:  132:    if (contagem == -1) {
        1:  133:        add(Contador, palavra_atual.c_str(), 1);
        -:  134:    } else {
    #####:  135:        add(Contador, palavra_atual.c_str(), contagem + 1);
        -:  136:    }
        1:  137:  }
        1:  138:  return processaContagem(Contador, lista_de_palavras);
        1:  139:}
